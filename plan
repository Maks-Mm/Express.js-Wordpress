Nice — I’ll give you a concrete, step-by-step implementation plan with exactly what to do, which files to create, commands to run, time/effort estimates, and deliverables for each step. I’ll assume you’ll implement this yourself (you said you code at a mid level), and I’ll include optional parts when you want to outsource. No questions — I’ll pick reasonable defaults (Node 18+, TypeScript optional, MongoDB Atlas, Vercel/Render). Let’s go.

Implementation plan — step-by-step (detailed)

> Goal: Extend headless WordPress + Express + React to automatically fetch Dortmund local news and render them together with WordPress posts.



Total recommended scope if you do it yourself: ~80–110 hours over 4–6 weeks part-time. I’ll break this into 8 concrete milestones with files, commands, and estimates.


---

Milestone 0 — Prep & repo (1–2 hours)

Outcome: Single monorepo or two repos (backend + frontend) with basic README and dev scripts.

1. Create repo(s)



# backend
mkdir dortmund-news-backend && cd dortmund-news-backend
git init
npm init -y

# frontend (separate or monorepo)
npx create-next-app@latest dortmund-news-frontend --typescript

2. Add basic README, license, and .env.example.


3. Setup branches: main, develop.



Estimated time: 1–2 hours


---

Milestone 1 — MongoDB + Mongoose model (3–5 hours)

Outcome: Working MongoDB connection and News model.

1. Create MongoDB Atlas cluster (free tier) and get connection string.


2. Install packages:



cd dortmund-news-backend
npm i express mongoose dotenv
npm i -D nodemon typescript @types/node @types/express

3. Add server.ts (or app.js if JS):



server.ts

import express from 'express';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
dotenv.config();

const app = express();
app.use(express.json());

const MONGO = process.env.MONGODB_URI!;
mongoose.connect(MONGO)
  .then(()=> console.log('MongoDB connected'))
  .catch(err=>console.error(err));

app.get('/', (_req, res) => res.json({ ok: true }));

app.listen(process.env.PORT || 5000, ()=> console.log('Server started'));

4. Create models/News.ts:



import { Schema, model } from 'mongoose';
const newsSchema = new Schema({
  title: { type: String, required: true },
  link: { type: String, required: true, unique: true },
  description: String,
  date: { type: Date, required: true },
  source: String,
  imageUrl: String,
  scrapedAt: { type: Date, default: Date.now }
}, { timestamps: true });

export default model('News', newsSchema);

5. Add .env.example with MONGODB_URI.



Deliverable: GET / returns {ok:true}, Mongoose connected, News model ready.

Estimated time: 3–5 hours


---

Milestone 2 — Scraper service (8–14 hours)

Outcome: Service that scrapes Dortmund official pages, returns normalized items.

1. Install scraping libs:



npm i axios cheerio date-fns

2. Add services/newsScraper.ts (class-based, multiple sources):



import axios from 'axios';
import cheerio from 'cheerio';
import { parse } from 'date-fns'; // optional

export default class DortmundNewsScraper {
  sources = [
    { name: 'Stadt Dortmund', url: 'https://www.dortmund.de/de/leben_in_dortmund/medien/aktuelle_nachrichten/index.html', base: 'https://www.dortmund.de' },
    // add others
  ];

  async scrapeAll() {
    const items = [];
    for (const s of this.sources) {
      try {
        const html = (await axios.get(s.url)).data;
        const $ = cheerio.load(html);
        $('.news-list-item, .teaser, article').each((_i, el) => {
          const title = $(el).find('h2, h3, .title').text().trim();
          let link = $(el).find('a').attr('href') || '';
          if (link && !link.startsWith('http')) link = s.base + link;
          const desc = $(el).find('p').first().text().trim();
          const dateText = $(el).find('.date, time').text().trim();
          const date = dateText ? new Date(dateText) : new Date();
          if (title && link) items.push({ title, link, description: desc, date, source: s.name });
        });
      } catch (e) { console.error('scrape error', s.name, e.message); }
    }
    return this.dedupe(items);
  }

  dedupe(items) {
    const map = new Map();
    items.forEach(i => { map.set(i.link || i.title, i); });
    return Array.from(map.values());
  }
}

3. Create test endpoint /api/scrape/test that returns scraped items (without saving).


4. Manually run and inspect results — adjust selectors for Dortmund pages. (This is the fiddly part; expect multiple iterations.)



Deliverable: GET /api/scrape/test returns array of normalized news items.

Estimated time: 8–14 hours (selector tuning and testing is the main time sink)


---

Milestone 3 — Save to DB + dedupe & API endpoints (6–10 hours)

Outcome: Save scraped items to MongoDB, provide /api/news and /api/news/scrape (manual trigger).

1. Create routes/news.ts:



import express from 'express';
import DortmundNewsScraper from '../services/newsScraper';
import News from '../models/News';

const router = express.Router();
const scraper = new DortmundNewsScraper();

router.get('/', async (_req, res) => {
  const items = await News.find().sort({ date: -1 }).limit(100);
  res.json(items);
});

router.post('/scrape', async (_req, res) => {
  const scraped = await scraper.scrapeAll();
  let inserted = 0;
  for (const item of scraped) {
    try {
      await News.findOneAndUpdate({ link: item.link }, item, { upsert: true });
      inserted++;
    } catch (e) { /* ignore dupes */ }
  }
  res.json({ message:'ok', count: inserted });
});

export default router;

2. Wire route in server.ts.


3. Add basic auth / secret header for POST /scrape (optional but recommended):



if (req.headers['x-scrape-key'] !== process.env.SCRAPE_KEY) return res.status(403).end();

4. Manual test: curl -X POST http://localhost:5000/api/news/scrape -H 'x-scrape-key: yourkey'



Deliverable: Persistent News collection + API to fetch and trigger scrape.

Estimated time: 6–10 hours


---

Milestone 4 — Scheduler (node-cron) & safety (2–4 hours)

Outcome: Automatic scraping on schedule + startup run, with environment-controlled interval.

1. Install:



npm i node-cron

2. Create services/scheduler.ts:



import cron from 'node-cron';
import DortmundNewsScraper from './newsScraper';
import News from '../models/News';

export default class Scheduler {
  scraper = new DortmundNewsScraper();
  start() {
    const cronExpr = process.env.SCRAPE_CRON || '0 */6 * * *';
    cron.schedule(cronExpr, async () => {
      console.log('Running scheduled scrape...');
      const items = await this.scraper.scrapeAll();
      for (const it of items) await News.findOneAndUpdate({ link: it.link }, it, { upsert: true });
    });
    // initial call
    setTimeout(() => this.scrapeNow(), 5000);
  }
  async scrapeNow() { /* same logic */ }
}

3. Start scheduler in server.ts after DB connect.


4. Add .env keys: SCRAPE_CRON, SCRAPE_KEY.



Safety notes: add rate-limiting and user-agent header to axios to be polite:

axios.get(url, { headers: { 'User-Agent': 'MyProjectBot/1.0 (+email)' }});

Estimated time: 2–4 hours


---

Milestone 5 — Frontend integration (React / Next.js) (10–16 hours)

Outcome: Component that fetches WordPress posts + /api/news and renders combined list with tabs.

1. In your frontend repo, create component components/PostsWithNews.tsx (you already have a version — integrate it).


2. API endpoints to call:

WordPress posts: https://your-wp-site/wp-json/wp/v2/posts?per_page=20

Your backend news: https://api.yourdomain.com/api/news



3. Implement useEffect to fetch both and combine:



const [posts, setPosts] = useState([]);
const [news, setNews] = useState([]);
useEffect(()=> {
  Promise.all([
    fetch(WP_URL).then(r=>r.json()),
    fetch(NEWS_API).then(r=>r.json())
  ]).then(([wp, n])=> {
    const combined = [...wp.map(p=>({...p, type:'wp'})), ...n.map(x=>({...x, type:'news'}))]
      .sort((a,b)=> new Date(b.date).getTime() - new Date(a.date).getTime());
    setContent(combined);
  });
}, []);

4. Add tabs (All / Posts / News), AOS init, and card UI. Use provided code from earlier message.


5. Add a small badge for source and external link for news items.



Deliverable: Single feed page showing combined content with filters and item detail view.

Estimated time: 10–16 hours


---

Milestone 6 — Testing, error handling, and polish (6–10 hours)

Outcome: Robust error handling, unit / manual tests, and UX polish.

1. Backend:

Validate stored items (title, link, date) before saving.

Try/catch around DB operations.

Add simple logging (console or a logger like pino).



2. Frontend:

Loading and error states.

Link sanitation (open external links in new tab).



3. Manual QA:

Run POST /api/news/scrape and check news appear.

Check date order, duplicates, and descriptions.



4. Optional: Add tests (Jest) for critical functions (scraper parsing).



Estimated time: 6–10 hours


---

Milestone 7 — Deployment & CI (6–10 hours)

Outcome: Production deployment, secured scrape trigger, and CI pipeline.

1. Backend deployment options:

Render/Railway (easy): connect repo, set env vars.

VPS (Hetzner/Contabo): Dockerize.



2. Example Dockerfile:



FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
CMD ["node", "dist/server.js"]

3. GitHub Actions for CI (build & test) and optional scheduled workflow to trigger scrape:



# .github/workflows/cron-scrape.yml
on:
  schedule:
    - cron: '0 */6 * * *'
jobs:
  trigger:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger scrape
        run: curl -X POST -H "x-scrape-key:${{ secrets.SCRAPE_KEY }}" https://api.yourdomain.com/api/news/scrape

4. Configure environment variables in host: MONGODB_URI, SCRAPE_KEY, SCRAPE_CRON, NODE_ENV=production.



Deliverable: Live backend on a public URL with scheduled scraping and frontend live.

Estimated time: 6–10 hours


---

Milestone 8 — Monitoring & Maintenance (ongoing)

Outcome: Alerts and plan for long term.

1. Monitoring: UptimeRobot for the backend, logs via Papertrail/LogDNA (optional).


2. Backups: MongoDB Atlas automated backups.


3. Maintenance tasks:

Every 1–3 months: check selectors, update scrapers when site changes.

Add new sources incrementally.




Estimated time: 1–4 hours monthly.


---

Timeline example (4–6 weeks, part-time)

Week 1: Milestones 0–2 (repo, DB, basic scraper test)
Week 2: Milestones 2–4 (finalize scraper, save DB, scheduler)
Week 3: Milestone 5 (frontend integration)
Week 4: Milestone 6 (testing + polish)
Week 5: Milestone 7 (deploy + CI)
Week 6: Buffer for bugs, selector fixes, and polish


---

Costs (concrete)

If you do it yourself (recommended):

Mentor / code review: €300–600 (1–2 months)

Infrastructure (monthly): €10–30

One-time domain: €10–20


If you hire a freelancer (outsourced per milestone approx):

Milestone 1–3 (backend core): €1,200 – 2,500

Milestone 4–7 (frontend + deploy): €1,200 – 3,000

Total outsourced: €2,500 – 6,000 (depending on rates and polish)



---

Security & legal checklist (must do)

1. Respect robots.txt and site terms. If a source forbids scraping, do not scrape it; use RSS or API alternatives.


2. Throttle requests, set a polite User-Agent.


3. Protect /api/news/scrape with SCRAPE_KEY or IP whitelist.


4. Avoid storing sensitive info in DB. Use env vars.




---

Quick copy-paste checklist to get started (first 48 hours)

1. Create backend folder and init: npm init -y


2. Install basics: npm i express mongoose dotenv axios cheerio node-cron


3. Add server.ts, .env.example, models/News.ts


4. Add simple services/newsScraper.ts with one source and GET /api/scrape/test


5. Run: npx ts-node-dev server.ts and open http://localhost:5000/api/scrape/test




---

If you want, I can now:

Produce the exact files for server.ts, models/News.ts, services/newsScraper.ts, and routes/news.ts (TypeScript) ready to paste into your project, or

Create a week-by-week checklist in a printable Markdown file for your personal tracker.


Which of those would you like me to generate right now?


*** 
steps => 


Perfect! I'll provide you with the exact files to get started immediately. Based on your existing Express.js project, I'll extend it with the Dortmund news functionality while maintaining your current WordPress integration.

## File 1: Updated `package.json`

```json
{
  "name": "wp-backend",
  "type": "module",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "dev": "node --watch server.js",
    "start": "node server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "axios": "^1.12.2",
    "cheerio": "^1.0.0-rc.12",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^5.1.0",
    "mongoose": "^8.2.1",
    "node-cron": "^3.0.3"
  }
}
```

## File 2: `.env.example`

```env
MONGODB_URI=mongodb://localhost:27017/dortmund-news
SCRAPE_KEY=your-secret-key-here
SCRAPE_CRON=0 */6 * * *
PORT=5000
```

## File 3: Updated `server.js` (your main file)

```javascript
import express from "express";
import axios from "axios";
import cors from "cors";
import mongoose from "mongoose";
import dotenv from "dotenv";
import newsRoutes from "./routes/news.js";
import Scheduler from "./services/scheduler.js";

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json());

// MongoDB connection
const MONGO_URI = process.env.MONGODB_URI || "mongodb://localhost:27017/dortmund-news";
mongoose.connect(MONGO_URI)
  .then(() => console.log("✅ MongoDB connected"))
  .catch(err => console.error("❌ MongoDB connection error:", err));

// Start scheduler
const scheduler = new Scheduler();
scheduler.start();

// Routes
app.use("/api/news", newsRoutes);

const WP_API = "https://public-api.wordpress.com/wp-v2/sites/firstproduc.wordpress.com";

// ✅ Your existing WordPress posts endpoint
app.get("/api/posts", async (req, res) => {
  console.log("📥 Fetching posts from WordPress...");
  try {
    const url = `${WP_API}/posts`;
    console.log("🔗 URL:", url);
    const wpResponse = await axios.get(url);
    console.log(`✅ Received ${wpResponse.data.length} posts`);
    res.json(wpResponse.data);
  } catch (err) {
    console.error("❌ Error fetching posts:", err.response?.status, err.message);
    res.status(500).json({
      error: "Failed to fetch posts",
      details: err.response?.data || err.message
    });
  }
});

// ✅ New combined endpoint for both posts and news
app.get("/api/content", async (req, res) => {
  console.log("📥 Fetching combined content...");
  try {
    const [postsResponse, newsResponse] = await Promise.all([
      axios.get(`${WP_API}/posts`).catch(err => {
        console.error("WordPress fetch failed:", err.message);
        return { data: [] };
      }),
      axios.get(`http://localhost:${process.env.PORT || 5000}/api/news`).catch(err => {
        console.error("News fetch failed:", err.message);
        return { data: [] };
      })
    ]);

    const posts = postsResponse.data.map(post => ({
      ...post,
      type: 'wp',
      id: `wp-${post.id}`
    }));

    const news = newsResponse.data.map(item => ({
      ...item,
      type: 'news',
      id: `news-${item._id}`,
      title: { rendered: item.title },
      excerpt: { rendered: item.description || '' },
      content: { rendered: item.description || '' },
      date: item.date
    }));

    const combined = [...posts, ...news].sort((a, b) => 
      new Date(b.date).getTime() - new Date(a.date).getTime()
    );

    res.json(combined);
  } catch (err) {
    console.error("❌ Error fetching combined content:", err.message);
    res.status(500).json({
      error: "Failed to fetch content",
      details: err.message
    });
  }
});

// Health check endpoint
app.get("/api/health", (req, res) => {
  res.json({ 
    status: "OK", 
    message: "Server is running",
    services: {
      database: mongoose.connection.readyState === 1 ? "Connected" : "Disconnected",
      scraping: "Active"
    }
  });
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log("✅ Express backend running on http://localhost:" + PORT);
  console.log("📝 Available endpoints:");
  console.log("   GET /api/health - Health check");
  console.log("   GET /api/posts - WordPress posts only");
  console.log("   GET /api/news - Dortmund news only");
  console.log("   GET /api/content - Combined posts + news");
  console.log("   POST /api/news/scrape - Manual scrape trigger");
});
```

## File 4: `models/News.js`

```javascript
import { Schema, model } from 'mongoose';

const newsSchema = new Schema({
  title: { 
    type: String, 
    required: true,
    trim: true
  },
  link: { 
    type: String, 
    required: true, 
    unique: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  date: { 
    type: Date, 
    required: true 
  },
  source: {
    type: String,
    required: true
  },
  imageUrl: {
    type: String,
    trim: true
  },
  scrapedAt: { 
    type: Date, 
    default: Date.now 
  }
}, { 
  timestamps: true 
});

// Index for faster queries
newsSchema.index({ date: -1 });
newsSchema.index({ link: 1 });

export default model('News', newsSchema);
```

## File 5: `services/newsScraper.js`

```javascript
import axios from "axios";
import * as cheerio from "cheerio";

export default class DortmundNewsScraper {
  constructor() {
    this.sources = [
      { 
        name: 'Stadt Dortmund', 
        url: 'https://www.dortmund.de/de/leben_in_dortmund/medien/aktuelle_nachrichten/index.html', 
        base: 'https://www.dortmund.de' 
      },
      { 
        name: 'Dortmund DE News', 
        url: 'https://www.dortmund.de/de/leben_in_dortmund/medien/aktuelle_nachrichten/', 
        base: 'https://www.dortmund.de' 
      }
    ];
  }

  async scrapeAll() {
    const allItems = [];
    
    for (const source of this.sources) {
      try {
        console.log(`🔍 Scraping ${source.name}...`);
        const items = await this.scrapeSource(source);
        allItems.push(...items);
      } catch (error) {
        console.error(`❌ Error scraping ${source.name}:`, error.message);
      }
    }

    return this.dedupe(allItems);
  }

  async scrapeSource(source) {
    try {
      const response = await axios.get(source.url, {
        timeout: 10000,
        headers: {
          'User-Agent': 'DortmundNewsBot/1.0 (+http://localhost:5000)'
        }
      });

      const $ = cheerio.load(response.data);
      const items = [];

      // Try multiple selectors for different page structures
      $('.news-list-item, .teaser, article, .news-item, .item').each((index, element) => {
        try {
          const $el = $(element);
          
          // Extract title
          const title = $el.find('h2, h3, .title, .news-title, a').first().text().trim();
          if (!title || title.length < 5) return;

          // Extract link
          let link = $el.find('a').attr('href') || '';
          if (link && !link.startsWith('http')) {
            link = source.base + link;
          }
          if (!link) return;

          // Extract description
          const description = $el.find('p, .description, .excerpt, .summary').first().text().trim() || 
                            title.substring(0, 200) + '...';

          // Extract date - try multiple date formats
          const dateText = $el.find('.date, time, .news-date, .published').text().trim();
          const date = this.parseDate(dateText);

          items.push({
            title,
            link,
            description,
            date,
            source: source.name,
            imageUrl: $el.find('img').attr('src') || ''
          });
        } catch (itemError) {
          console.error('Error parsing item:', itemError.message);
        }
      });

      console.log(`✅ ${source.name}: Found ${items.length} items`);
      return items;

    } catch (error) {
      console.error(`❌ Failed to scrape ${source.name}:`, error.message);
      return [];
    }
  }

  parseDate(dateText) {
    if (!dateText) return new Date();
    
    // Try to parse common German date formats
    const cleanDate = dateText.replace(/\./g, '/').trim();
    const parsed = new Date(cleanDate);
    
    return isNaN(parsed.getTime()) ? new Date() : parsed;
  }

  dedupe(items) {
    const seen = new Set();
    return items.filter(item => {
      const key = item.link.toLowerCase();
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }
}
```

## File 6: `services/scheduler.js`

```javascript
import cron from 'node-cron';
import DortmundNewsScraper from './newsScraper.js';
import News from '../models/News.js';

export default class Scheduler {
  constructor() {
    this.scraper = new DortmundNewsScraper();
    this.isScraping = false;
  }

  start() {
    // Schedule scraping every 6 hours
    const cronExpr = process.env.SCRAPE_CRON || '0 */6 * * *';
    
    cron.schedule(cronExpr, async () => {
      await this.scrapeNow();
    });

    console.log('✅ Scheduler started with cron:', cronExpr);

    // Initial scrape after 10 seconds
    setTimeout(() => {
      this.scrapeNow();
    }, 10000);
  }

  async scrapeNow() {
    if (this.isScraping) {
      console.log('⏳ Scraping already in progress, skipping...');
      return;
    }

    this.isScraping = true;
    console.log('🔄 Starting scheduled scrape...');

    try {
      const scrapedItems = await this.scraper.scrapeAll();
      let inserted = 0;

      for (const item of scrapedItems) {
        try {
          await News.findOneAndUpdate(
            { link: item.link },
            { ...item, scrapedAt: new Date() },
            { upsert: true, new: true }
          );
          inserted++;
        } catch (dbError) {
          console.error('❌ DB error for item:', item.title, dbError.message);
        }
      }

      console.log(`✅ Scraping completed: ${inserted} items processed`);
    } catch (error) {
      console.error('❌ Scraping failed:', error.message);
    } finally {
      this.isScraping = false;
    }
  }
}
```

## File 7: `routes/news.js`

```javascript
import express from 'express';
import DortmundNewsScraper from '../services/newsScraper.js';
import News from '../models/News.js';

const router = express.Router();
const scraper = new DortmundNewsScraper();

// GET /api/news - Get all news (paginated)
router.get('/', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 50;
    const skip = (page - 1) * limit;

    const items = await News.find()
      .sort({ date: -1 })
      .skip(skip)
      .limit(limit)
      .lean();

    const total = await News.countDocuments();

    res.json({
      items,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('❌ Error fetching news:', error);
    res.status(500).json({ 
      error: 'Failed to fetch news',
      details: error.message 
    });
  }
});

// POST /api/news/scrape - Manual scrape trigger
router.post('/scrape', async (req, res) => {
  // Basic protection - check for scrape key
  const scrapeKey = req.headers['x-scrape-key'];
  if (scrapeKey !== process.env.SCRAPE_KEY) {
    return res.status(403).json({ 
      error: 'Forbidden - invalid scrape key' 
    });
  }

  try {
    console.log('🔄 Manual scrape triggered...');
    const scrapedItems = await scraper.scrapeAll();
    let inserted = 0;

    for (const item of scrapedItems) {
      try {
        await News.findOneAndUpdate(
          { link: item.link },
          { ...item, scrapedAt: new Date() },
          { upsert: true }
        );
        inserted++;
      } catch (dbError) {
        // Continue on duplicate errors
        if (dbError.code !== 11000) {
          console.error('DB error:', dbError.message);
        }
      }
    }

    res.json({ 
      message: 'Scraping completed', 
      scraped: scrapedItems.length,
      inserted,
      duplicates: scrapedItems.length - inserted
    });

  } catch (error) {
    console.error('❌ Scraping error:', error);
    res.status(500).json({ 
      error: 'Scraping failed',
      details: error.message 
    });
  }
});

// GET /api/news/test - Test scraping without saving
router.get('/test', async (req, res) => {
  try {
    const items = await scraper.scrapeAll();
    res.json({
      message: 'Test scrape completed',
      count: items.length,
      items: items.slice(0, 10) // Return first 10 for inspection
    });
  } catch (error) {
    res.status(500).json({ 
      error: 'Test scrape failed',
      details: error.message 
    });
  }
});

export default router;
```

## File 8: Updated React Component `Posts.jsx`

```jsx
import { useEffect, useState } from "react";
import AOS from "aos";
import "aos/dist/aos.css";

interface WordPressPost {
  id: number;
  title: { rendered: string };
  content: { rendered: string };
  excerpt: { rendered: string };
  date: string;
  slug: string;
  featured_media?: number;
  type?: string;
}

interface NewsItem {
  _id: string;
  title: string;
  link: string;
  description: string;
  date: string;
  source: string;
  imageUrl?: string;
  type: string;
}

type ContentItem = WordPressPost | NewsItem;

export default function Posts() {
  const [content, setContent] = useState<ContentItem[]>([]);
  const [selectedItem, setSelectedItem] = useState<ContentItem | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<'all' | 'posts' | 'news'>('all');

  useEffect(() => {
    fetchContent();
    AOS.init({ duration: 1000, once: true });
  }, []);

  useEffect(() => {
    AOS.refresh();
  }, [content, selectedItem]);

  const fetchContent = async () => {
    setLoading(true);
    setError(null);
    setSelectedItem(null);

    try {
      const res = await fetch("http://localhost:5000/api/content");
      if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
      const data: ContentItem[] = await res.json();
      setContent(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load content");
    } finally {
      setLoading(false);
    }
  };

  const handleItemClick = (item: ContentItem) => {
    setSelectedItem(item);
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  const handleBackClick = () => setSelectedItem(null);

  const filteredContent = content.filter(item => {
    if (activeTab === 'all') return true;
    if (activeTab === 'posts') return item.type === 'wp';
    if (activeTab === 'news') return item.type === 'news';
    return true;
  });

  const getItemTitle = (item: ContentItem) => {
    if ('title' in item && typeof item.title === 'object') {
      return item.title.rendered;
    }
    return item.title;
  };

  const getItemDescription = (item: ContentItem) => {
    if (item.type === 'wp') {
      const wpItem = item as WordPressPost;
      return wpItem.excerpt.rendered.length > 200 
        ? wpItem.excerpt.rendered.slice(0, 200) + "..." 
        : wpItem.excerpt.rendered;
    } else {
      const newsItem = item as NewsItem;
      return newsItem.description.length > 200
        ? newsItem.description.slice(0, 200) + "..."
        : newsItem.description;
    }
  };

  const getItemDate = (item: ContentItem) => {
    return new Date(item.date).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };

  if (loading) {
    return (
      <div className="flex flex-col justify-center items-center min-h-[50vh] text-center" data-aos="fade-up">
        <div className="loader mb-3"></div>
        <p className="text-gray-600">Loading content...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-16" data-aos="fade-up">
        <p className="text-red-400 font-semibold mb-4">⚠️ {error}</p>
        <button onClick={fetchContent} className="btn-glass">
          Try Again
        </button>
      </div>
    );
  }

  if (selectedItem) {
    const isNews = selectedItem.type === 'news';
    
    return (
      <div className="max-w-3xl mx-auto post-card mt-8" data-aos="fade-up">
        <button onClick={handleBackClick} className="btn-glass mb-6">
          ← Back to {isNews ? 'News' : 'Posts'}
        </button>

        {isNews && (
          <div className="flex items-center gap-2 mb-4">
            <span className="px-2 py-1 bg-blue-100 text-blue-800 text-xs font-medium rounded">
              {selectedItem.source}
            </span>
            <span className="px-2 py-1 bg-green-100 text-green-800 text-xs font-medium rounded">
              News
            </span>
          </div>
        )}

        <h1
          className="text-3xl font-bold text-gray-900 mb-2"
          dangerouslySetInnerHTML={{ 
            __html: getItemTitle(selectedItem) 
          }}
        />
        <p className="text-sm text-gray-500 mb-6">
          {getItemDate(selectedItem)}
        </p>

        {isNews ? (
          <div className="wp-content prose prose-lg max-w-none">
            <p className="text-gray-700 leading-relaxed mb-6">
              {(selectedItem as NewsItem).description}
            </p>
            <a 
              href={(selectedItem as NewsItem).link} 
              target="_blank" 
              rel="noopener noreferrer"
              className="btn-glass inline-flex items-center gap-2"
            >
              Read Full Article ↗
            </a>
          </div>
        ) : (
          <div
            className="wp-content prose prose-lg max-w-none"
            dangerouslySetInnerHTML={{ 
              __html: (selectedItem as WordPressPost).content.rendered 
            }}
          />
        )}
      </div>
    );
  }

  return (
    <div className="max-w-3xl mx-auto px-4 py-10">
      <header className="text-center mb-10" data-aos="fade-down">
        <h1 className="text-4xl font-bold text-gray-900 mb-2">News & Blog</h1>
        <p className="text-lg text-gray-600 mb-2">Latest posts and Dortmund news</p>
        {content.length > 0 && (
          <p className="text-sm text-gray-500">
            Showing {filteredContent.length} item{filteredContent.length !== 1 ? "s" : ""}
          </p>
        )}
      </header>

      {/* Tab Navigation */}
      <div className="flex justify-center mb-8" data-aos="fade-up">
        <div className="flex bg-gray-100 rounded-lg p-1">
          {[
            { key: 'all', label: 'All Content', count: content.length },
            { key: 'posts', label: 'Blog Posts', count: content.filter(item => item.type === 'wp').length },
            { key: 'news', label: 'Dortmund News', count: content.filter(item => item.type === 'news').length }
          ].map(tab => (
            <button
              key={tab.key}
              onClick={() => setActiveTab(tab.key as any)}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                activeTab === tab.key
                  ? 'bg-white text-gray-900 shadow-sm'
                  : 'text-gray-600 hover:text-gray-900'
              }`}
            >
              {tab.label} ({tab.count})
            </button>
          ))}
        </div>
      </div>

      {filteredContent.length === 0 ? (
        <div className="text-center py-12" data-aos="fade-up">
          <p className="text-gray-500 text-lg mb-4">No content found.</p>
          <button onClick={fetchContent} className="btn-glass">
            Refresh Content
          </button>
        </div>
      ) : (
        <div className="space-y-6">
          {filteredContent.map((item, index) => (
            <article
              key={item.id || item._id}
              className="post-card hover:shadow-xl transition-all duration-300"
              data-aos={index % 2 === 0 ? "fade-up" : "fade-right"}
            >
              {/* Source Badge */}
              {item.type === 'news' && (
                <div className="flex items-center gap-2 mb-3">
                  <span className="px-2 py-1 bg-blue-100 text-blue-800 text-xs font-medium rounded">
                    {(item as NewsItem).source}
                  </span>
                  <span className="px-2 py-1 bg-green-100 text-green-800 text-xs font-medium rounded">
                    News
                  </span>
                </div>
              )}

              <h2
                className="text-2xl font-semibold text-gray-900 mb-1 hover:text-blue-400 transition-colors cursor-pointer"
                onClick={() => handleItemClick(item)}
                dangerouslySetInnerHTML={{ __html: getItemTitle(item) }}
              />
              <p className="text-sm text-gray-500 mb-3">
                {getItemDate(item)}
              </p>

              <div
                className="text-gray-700 leading-relaxed mb-4"
                dangerouslySetInnerHTML={{
                  __html: getItemDescription(item),
                }}
              />

              <div className="flex items-center gap-3">
                <button
                  onClick={() => handleItemClick(item)}
                  className="btn-glass"
                >
                  Read {item.type === 'news' ? 'Full Article' : 'More'}
                </button>
                {item.type === 'news' && (
                  <a 
                    href={(item as NewsItem).link} 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="text-sm text-gray-500 hover:text-gray-700 transition-colors"
                  >
                    Open Original ↗
                  </a>
                )}
              </div>
            </article>
          ))}
        </div>
      )}
    </div>
  );
}
```

## Quick Start Commands:

```bash
# 1. Install new dependencies
npm install

# 2. Create .env file
cp .env.example .env

# 3. Update your .env with real values
# MONGODB_URI=mongodb+srv://...
# SCRAPE_KEY=your-secret-key

# 4. Start the server
npm run dev
```

## Immediate Testing:

1. **Test scraping**: `GET http://localhost:5000/api/news/test`
2. **Test combined content**: `GET http://localhost:5000/api/content` 
3. **Manual scrape**: `POST http://localhost:5000/api/news/scrape` with header `x-scrape-key: your-secret-key`

This extends your existing project with all the Dortmund news functionality while maintaining your current WordPress integration. The scraper will automatically run every 6 hours and you get a combined feed of both content types!